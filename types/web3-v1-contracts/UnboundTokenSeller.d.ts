/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type NewTokensToSell = ContractEventLog<{
  token: string;
  amountReceived: string;
  0: string;
  1: string;
}>;
export type PremiumPercentSet = ContractEventLog<{
  premium: string;
  0: string;
}>;
export type SwappedTokens = ContractEventLog<{
  tokenSold: string;
  tokenBought: string;
  soldAmount: string;
  boughtAmount: string;
  0: string;
  1: string;
  2: string;
  3: string;
}>;

export interface UnboundTokenSeller extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): UnboundTokenSeller;
  clone(): UnboundTokenSeller;
  methods: {
    controller(): NonPayableTransactionObject<string>;

    oracle(): NonPayableTransactionObject<string>;

    /**
     * Initialize the proxy contract with the acceptable premium rate and the address of the pool it is for.
     */
    initialize(
      pool: string,
      premiumPercent: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Receive `amount` of `token` from the pool.
     */
    handleUnbindToken(
      token: string,
      amount: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Set the premium rate as a percent.
     */
    setPremiumPercent(
      premiumPercent: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Execute a trade with UniSwap to sell some tokens held by the contract for some tokens desired by the pool and pays the caller the difference between the maximum input value and the actual paid amount.
     * @param amountOut Exact amount of `tokenOut` to receive from UniSwap
     * @param path Swap path to execute
     * @param tokenIn Token to sell to UniSwap
     * @param tokenOut Token to receive from UniSwapx
     */
    executeSwapTokensForExactTokens(
      tokenIn: string,
      tokenOut: string,
      amountOut: number | string | BN,
      path: string[]
    ): NonPayableTransactionObject<string>;

    /**
     * Executes a trade with UniSwap to sell some tokens held by the contract for some tokens desired by the pool and pays the caller any tokens received above the minimum acceptable output.
     * @param amountIn Exact amount of `tokenIn` to give UniSwap
     * @param path Swap path to execute
     * @param tokenIn Token to sell to UniSwap
     * @param tokenOut Token to receive from UniSwap
     */
    executeSwapExactTokensForTokens(
      tokenIn: string,
      tokenOut: string,
      amountIn: number | string | BN,
      path: string[]
    ): NonPayableTransactionObject<string>;

    /**
     * Swap exactly `amountIn` of `tokenIn` for at least `minAmountOut` of `tokenOut`.
     * @param amountIn Amount of `tokenIn` to sell to pool
     * @param minAmountOut Minimum amount of `tokenOut` to buy from pool
     * @param tokenIn Token to sell to pool
     * @param tokenOut Token to buy from pool
     */
    swapExactTokensForTokens(
      tokenIn: string,
      tokenOut: string,
      amountIn: number | string | BN,
      minAmountOut: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Swap up to `maxAmountIn` of `tokenIn` for exactly `amountOut` of `tokenOut`.
     * @param amountOut Amount of `tokenOut` to buy from pool
     * @param maxAmountIn Maximum amount of `tokenIn` to sell to pool
     * @param tokenIn Token to sell to pool
     * @param tokenOut Token to buy from pool
     */
    swapTokensForExactTokens(
      tokenIn: string,
      tokenOut: string,
      amountOut: number | string | BN,
      maxAmountIn: number | string | BN
    ): NonPayableTransactionObject<string>;

    getPremiumPercent(): NonPayableTransactionObject<string>;

    /**
     * Calculate the amount of `tokenIn` the pool will accept for `amountOut` of `tokenOut`.
     */
    calcInGivenOut(
      tokenIn: string,
      tokenOut: string,
      amountOut: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Calculate the amount of `tokenOut` the pool will give for `amountIn` of `tokenIn`.
     */
    calcOutGivenIn(
      tokenIn: string,
      tokenOut: string,
      amountIn: number | string | BN
    ): NonPayableTransactionObject<string>;
  };
  events: {
    NewTokensToSell(cb?: Callback<NewTokensToSell>): EventEmitter;
    NewTokensToSell(
      options?: EventOptions,
      cb?: Callback<NewTokensToSell>
    ): EventEmitter;

    PremiumPercentSet(cb?: Callback<PremiumPercentSet>): EventEmitter;
    PremiumPercentSet(
      options?: EventOptions,
      cb?: Callback<PremiumPercentSet>
    ): EventEmitter;

    SwappedTokens(cb?: Callback<SwappedTokens>): EventEmitter;
    SwappedTokens(
      options?: EventOptions,
      cb?: Callback<SwappedTokens>
    ): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "NewTokensToSell", cb: Callback<NewTokensToSell>): void;
  once(
    event: "NewTokensToSell",
    options: EventOptions,
    cb: Callback<NewTokensToSell>
  ): void;

  once(event: "PremiumPercentSet", cb: Callback<PremiumPercentSet>): void;
  once(
    event: "PremiumPercentSet",
    options: EventOptions,
    cb: Callback<PremiumPercentSet>
  ): void;

  once(event: "SwappedTokens", cb: Callback<SwappedTokens>): void;
  once(
    event: "SwappedTokens",
    options: EventOptions,
    cb: Callback<SwappedTokens>
  ): void;
}
