/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type AdminAccessGranted = ContractEventLog<{
  newAdmin: string;
  0: string;
}>;
export type AdminAccessRevoked = ContractEventLog<{
  newAdmin: string;
  0: string;
}>;

export interface IProxyManagerAccessControl extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): IProxyManagerAccessControl;
  clone(): IProxyManagerAccessControl;
  methods: {
    /**
     * Checks whether `account` has administrator access.
     */
    hasAdminAccess(account: string): NonPayableTransactionObject<boolean>;

    /**
     * Gets the address of the proxy manager.
     */
    proxyManager(): NonPayableTransactionObject<string>;

    /**
     * Allows `deployer` to deploy many-to-one proxies.
     */
    approveDeployer(deployer: string): NonPayableTransactionObject<void>;

    /**
     * Prevents `deployer` from deploying many-to-one proxies.
     */
    revokeDeployerApproval(deployer: string): NonPayableTransactionObject<void>;

    /**
     * Grants admin access to `admin`.
     */
    grantAdminAccess(admin: string): NonPayableTransactionObject<void>;

    /**
     * Revokes admin access from `admin`.
     */
    revokeAdminAccess(admin: string): NonPayableTransactionObject<void>;

    /**
     * Transfers ownership of the proxy manager.
     */
    transferManagerOwnership(
      newOwner: string
    ): NonPayableTransactionObject<void>;

    /**
     * Creates a many-to-one proxy relationship. Deploys an implementation holder contract which stores the implementation address for many proxies. The implementation address can be updated on the holder to change the runtime code used by all its proxies.
     * @param implementation Address with the runtime code the proxies should use.
     * @param implementationID ID for the implementation, used to identify the proxies that use it. Also used as the salt in the create2 call when deploying the implementation holder contract.
     */
    createManyToOneProxyRelationship(
      implementationID: string | number[],
      implementation: string
    ): NonPayableTransactionObject<void>;

    /**
     * Lock the current implementation for `proxyAddress` so that it can never be upgraded again.
     */
    lockImplementationManyToOne(
      implementationID: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * Lock the current implementation for `proxyAddress` so that it can never be upgraded again.
     */
    lockImplementationOneToOne(
      proxyAddress: string
    ): NonPayableTransactionObject<void>;

    /**
     * Updates the implementation address for a many-to-one proxy relationship.
     * @param implementation Address with the runtime code the proxies should use.
     * @param implementationID Identifier for the implementation.
     */
    setImplementationAddressManyToOne(
      implementationID: string | number[],
      implementation: string
    ): NonPayableTransactionObject<void>;

    /**
     * Updates the implementation address for a one-to-one proxy. Note: This could work for many-to-one as well if the caller provides the implementation holder address in place of the proxy address, as they use the same access control and update mechanism.
     * @param implementation Address with the runtime code for the proxy to use.
     * @param proxyAddress Address of the deployed proxy
     */
    setImplementationAddressOneToOne(
      proxyAddress: string,
      implementation: string
    ): NonPayableTransactionObject<void>;

    /**
     * Deploy a proxy contract with a one-to-one relationship with its implementation. The proxy will have its own implementation address which can be updated by the proxy manager.
     * @param implementation Address of the contract with the runtime code that the proxy should use.
     * @param suppliedSalt Salt provided by the account requesting deployment.
     */
    deployProxyOneToOne(
      suppliedSalt: string | number[],
      implementation: string
    ): NonPayableTransactionObject<string>;

    /**
     * Deploy a proxy with a many-to-one relationship with its implemenation. The proxy will call the implementation holder for every transaction to determine the address to use in calls.
     * @param implementationID Identifier for the proxy's implementation.
     * @param suppliedSalt Salt provided by the account requesting deployment.
     */
    deployProxyManyToOne(
      implementationID: string | number[],
      suppliedSalt: string | number[]
    ): NonPayableTransactionObject<string>;
  };
  events: {
    AdminAccessGranted(cb?: Callback<AdminAccessGranted>): EventEmitter;
    AdminAccessGranted(
      options?: EventOptions,
      cb?: Callback<AdminAccessGranted>
    ): EventEmitter;

    AdminAccessRevoked(cb?: Callback<AdminAccessRevoked>): EventEmitter;
    AdminAccessRevoked(
      options?: EventOptions,
      cb?: Callback<AdminAccessRevoked>
    ): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "AdminAccessGranted", cb: Callback<AdminAccessGranted>): void;
  once(
    event: "AdminAccessGranted",
    options: EventOptions,
    cb: Callback<AdminAccessGranted>
  ): void;

  once(event: "AdminAccessRevoked", cb: Callback<AdminAccessRevoked>): void;
  once(
    event: "AdminAccessRevoked",
    options: EventOptions,
    cb: Callback<AdminAccessRevoked>
  ): void;
}
