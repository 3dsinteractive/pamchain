/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import BN from "bn.js";
import { ContractOptions } from "web3-eth-contract";
import { EventLog } from "web3-core";
import { EventEmitter } from "events";
import {
  Callback,
  PayableTransactionObject,
  NonPayableTransactionObject,
  BlockType,
  ContractEventLog,
  BaseContract,
} from "./types";

interface EventOptions {
  filter?: object;
  fromBlock?: BlockType;
  topics?: string[];
}

export type Approval = ContractEventLog<{
  src: string;
  dst: string;
  amt: string;
  0: string;
  1: string;
  2: string;
}>;
export type LOG_DENORM_UPDATED = ContractEventLog<{
  token: string;
  newDenorm: string;
  0: string;
  1: string;
}>;
export type LOG_DESIRED_DENORM_SET = ContractEventLog<{
  token: string;
  desiredDenorm: string;
  0: string;
  1: string;
}>;
export type LOG_EXIT = ContractEventLog<{
  caller: string;
  tokenOut: string;
  tokenAmountOut: string;
  0: string;
  1: string;
  2: string;
}>;
export type LOG_JOIN = ContractEventLog<{
  caller: string;
  tokenIn: string;
  tokenAmountIn: string;
  0: string;
  1: string;
  2: string;
}>;
export type LOG_MAX_TOKENS_UPDATED = ContractEventLog<{
  maxPoolTokens: string;
  0: string;
}>;
export type LOG_MINIMUM_BALANCE_UPDATED = ContractEventLog<{
  token: string;
  minimumBalance: string;
  0: string;
  1: string;
}>;
export type LOG_PUBLIC_SWAP_ENABLED = ContractEventLog<{}>;
export type LOG_SWAP = ContractEventLog<{
  caller: string;
  tokenIn: string;
  tokenOut: string;
  tokenAmountIn: string;
  tokenAmountOut: string;
  0: string;
  1: string;
  2: string;
  3: string;
  4: string;
}>;
export type LOG_SWAP_FEE_UPDATED = ContractEventLog<{
  swapFee: string;
  0: string;
}>;
export type LOG_TOKEN_ADDED = ContractEventLog<{
  token: string;
  desiredDenorm: string;
  minimumBalance: string;
  0: string;
  1: string;
  2: string;
}>;
export type LOG_TOKEN_READY = ContractEventLog<{
  token: string;
  0: string;
}>;
export type LOG_TOKEN_REMOVED = ContractEventLog<{
  token: string;
  0: string;
}>;
export type Transfer = ContractEventLog<{
  src: string;
  dst: string;
  amt: string;
  0: string;
  1: string;
  2: string;
}>;

export interface IndexPool extends BaseContract {
  constructor(
    jsonInterface: any[],
    address?: string,
    options?: ContractOptions
  ): IndexPool;
  clone(): IndexPool;
  methods: {
    VERSION_NUMBER(): NonPayableTransactionObject<string>;

    allowance(src: string, dst: string): NonPayableTransactionObject<string>;

    approve(
      dst: string,
      amt: number | string | BN
    ): NonPayableTransactionObject<boolean>;

    balanceOf(whom: string): NonPayableTransactionObject<string>;

    decimals(): NonPayableTransactionObject<string>;

    decreaseApproval(
      dst: string,
      amt: number | string | BN
    ): NonPayableTransactionObject<boolean>;

    increaseApproval(
      dst: string,
      amt: number | string | BN
    ): NonPayableTransactionObject<boolean>;

    name(): NonPayableTransactionObject<string>;

    symbol(): NonPayableTransactionObject<string>;

    totalSupply(): NonPayableTransactionObject<string>;

    transfer(
      dst: string,
      amt: number | string | BN
    ): NonPayableTransactionObject<boolean>;

    transferFrom(
      src: string,
      dst: string,
      amt: number | string | BN
    ): NonPayableTransactionObject<boolean>;

    /**
     * Sets the controller address and the token name & symbol. Note: This saves on storage costs for multi-step pool deployment.
     * @param controller Controller of the pool
     * @param name Name of the pool token
     * @param symbol Symbol of the pool token
     */
    configure(
      controller: string,
      name: string,
      symbol: string
    ): NonPayableTransactionObject<void>;

    /**
     * Sets up the initial assets for the pool. Note: `tokenProvider` must have approved the pool to transfer the corresponding `balances` of `tokens`.
     * @param balances Initial balances to transfer
     * @param denorms Initial denormalized weights for the tokens
     * @param tokenProvider Address to transfer the balances from
     * @param tokens Underlying tokens to initialize the pool with
     */
    initialize(
      tokens: string[],
      balances: (number | string | BN)[],
      denorms: (number | string | BN)[],
      tokenProvider: string,
      unbindHandler: string
    ): NonPayableTransactionObject<void>;

    /**
     * Sets the maximum number of pool tokens that can be minted. This value will be used in the alpha to limit the maximum damage that can be caused by a catastrophic error. It can be gradually increased as the pool continues to not be exploited. If it is set to 0, the limit will be removed.
     */
    setMaxPoolTokens(
      maxPoolTokens: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Set the swap fee. Note: Swap fee must be between 0.0001% and 10%
     */
    setSwapFee(
      swapFee: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Delegate a comp-like governance token to an address specified by the controller.
     */
    delegateCompLikeToken(
      token: string,
      delegatee: string
    ): NonPayableTransactionObject<void>;

    /**
     * Sets the desired weights for the pool tokens, which will be adjusted over time as they are swapped. Note: This does not check for duplicate tokens or that the total of the desired weights is equal to the target total weight (25). Those assumptions should be met in the controller. Further, the provided tokens should only include the tokens which are not set for removal.
     */
    reweighTokens(
      tokens: string[],
      desiredDenorms: (number | string | BN)[]
    ): NonPayableTransactionObject<void>;

    /**
     * Update the underlying assets held by the pool and their associated weights. Tokens which are not currently bound will be gradually added as they are swapped in to reach the provided minimum balances, which must be an amount of tokens worth the minimum weight of the total pool value. If a currently bound token is not received in this call, the token's desired weight will be set to 0.
     */
    reindexTokens(
      tokens: string[],
      desiredDenorms: (number | string | BN)[],
      minimumBalances: (number | string | BN)[]
    ): NonPayableTransactionObject<void>;

    /**
     * Updates the minimum balance for an uninitialized token. This becomes useful if a token's external price significantly rises after being bound, since the pool can not send a token out until it reaches the minimum balance.
     */
    setMinimumBalance(
      token: string,
      minimumBalance: number | string | BN
    ): NonPayableTransactionObject<void>;

    /**
     * Mint new pool tokens by providing the proportional amount of each underlying token's balance relative to the proportion of pool tokens minted. For any underlying tokens which are not initialized, the caller must provide the proportional share of the minimum balance for the token rather than the actual balance.
     * @param maxAmountsIn Maximum amount of each token to pay in the same order as the pool's _tokens list.
     * @param poolAmountOut Amount of pool tokens to mint
     */
    joinPool(
      poolAmountOut: number | string | BN,
      maxAmountsIn: (number | string | BN)[]
    ): NonPayableTransactionObject<void>;

    /**
     * Pay `tokenAmountIn` of `tokenIn` to mint at least `minPoolAmountOut` pool tokens. The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other underlying tokens. Thus a swap fee is charged against the input tokens.
     * @param minPoolAmountOut Minimum amount of pool tokens to mint
     * @param tokenAmountIn Exact amount of `tokenIn` to pay
     * @param tokenIn Token to send the pool
     */
    joinswapExternAmountIn(
      tokenIn: string,
      tokenAmountIn: number | string | BN,
      minPoolAmountOut: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Pay up to `maxAmountIn` of `tokenIn` to mint exactly `poolAmountOut`. The pool implicitly swaps `(1- weightTokenIn) * tokenAmountIn` to the other underlying tokens. Thus a swap fee is charged against the input tokens.
     * @param maxAmountIn Maximum amount of `tokenIn` to pay
     * @param poolAmountOut Exact amount of pool tokens to mint
     * @param tokenIn Token to send the pool
     */
    joinswapPoolAmountOut(
      tokenIn: string,
      poolAmountOut: number | string | BN,
      maxAmountIn: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Burns `poolAmountIn` pool tokens in exchange for the amounts of each underlying token's balance proportional to the ratio of tokens burned to total pool supply. The amount of each token transferred to the caller must be greater than or equal to the associated minimum output amount from the `minAmountsOut` array.
     * @param minAmountsOut Minimum amount of each token to receive, in the same order as the pool's _tokens list.
     * @param poolAmountIn Exact amount of pool tokens to burn
     */
    exitPool(
      poolAmountIn: number | string | BN,
      minAmountsOut: (number | string | BN)[]
    ): NonPayableTransactionObject<void>;

    /**
     * Burns `poolAmountIn` pool tokens in exchange for at least `minAmountOut` of `tokenOut`. Returns the number of tokens sent to the caller. The pool implicitly burns the tokens for all underlying tokens and swaps them to the desired output token. A swap fee is charged against the output tokens.
     * @param minAmountOut Minimum amount of `tokenOut` to receive
     * @param poolAmountIn Exact amount of pool tokens to burn
     * @param tokenOut Token to receive
     */
    exitswapPoolAmountIn(
      tokenOut: string,
      poolAmountIn: number | string | BN,
      minAmountOut: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Burn up to `maxPoolAmountIn` for exactly `tokenAmountOut` of `tokenOut`. Returns the number of pool tokens burned. The pool implicitly burns the tokens for all underlying tokens and swaps them to the desired output token. A swap fee is charged against the output tokens.
     * @param maxPoolAmountIn Maximum amount of pool tokens to burn
     * @param tokenAmountOut Exact amount of `tokenOut` to receive
     * @param tokenOut Token to receive
     */
    exitswapExternAmountOut(
      tokenOut: string,
      tokenAmountOut: number | string | BN,
      maxPoolAmountIn: number | string | BN
    ): NonPayableTransactionObject<string>;

    /**
     * Absorb any tokens that have been sent to the pool. If the token is not bound, it will be sent to the unbound token handler.
     */
    gulp(token: string): NonPayableTransactionObject<void>;

    /**
     * Execute a flash loan, transferring `amount` of `token` to `recipient`. `amount` must be repaid with `swapFee` interest by the end of the transaction.
     * @param amount Amount to borrow
     * @param data Data to send to the recipient in `receiveFlashLoan` call
     * @param recipient Must implement the IFlashLoanRecipient interface
     * @param token Token to borrow
     */
    flashBorrow(
      recipient: string,
      token: string,
      amount: number | string | BN,
      data: string | number[]
    ): NonPayableTransactionObject<void>;

    /**
     * Execute a token swap with a specified amount of input tokens and a minimum amount of output tokens. Note: Will revert if `tokenOut` is uninitialized.
     * @param maxPrice Maximum ratio of input to output tokens
     * @param minAmountOut Minimum amount of `tokenOut` to receive
     * @param tokenAmountIn Exact amount of `tokenIn` to swap in
     * @param tokenIn Token to swap in
     * @param tokenOut Token to swap out
     */
    swapExactAmountIn(
      tokenIn: string,
      tokenAmountIn: number | string | BN,
      tokenOut: string,
      minAmountOut: number | string | BN,
      maxPrice: number | string | BN
    ): NonPayableTransactionObject<{
      0: string;
      1: string;
    }>;

    /**
     * Trades at most `maxAmountIn` of `tokenIn` for exactly `tokenAmountOut` of `tokenOut`. Returns the actual input amount and the new spot price after the swap, which can not exceed `maxPrice`.
     * @param maxAmountIn Maximum amount of `tokenIn` to pay
     * @param maxPrice Maximum ratio of input to output tokens
     * @param tokenAmountOut Exact amount of `tokenOut` to receive
     * @param tokenIn Token to swap in
     * @param tokenOut Token to swap out
     */
    swapExactAmountOut(
      tokenIn: string,
      maxAmountIn: number | string | BN,
      tokenOut: string,
      tokenAmountOut: number | string | BN,
      maxPrice: number | string | BN
    ): NonPayableTransactionObject<{
      0: string;
      1: string;
    }>;

    /**
     * Check if swapping tokens and joining the pool is allowed.
     */
    isPublicSwap(): NonPayableTransactionObject<boolean>;

    getSwapFee(): NonPayableTransactionObject<string>;

    /**
     * Returns the controller address.
     */
    getController(): NonPayableTransactionObject<string>;

    getMaxPoolTokens(): NonPayableTransactionObject<string>;

    /**
     * Check if a token is bound to the pool.
     */
    isBound(t: string): NonPayableTransactionObject<boolean>;

    /**
     * Get the number of tokens bound to the pool.
     */
    getNumTokens(): NonPayableTransactionObject<string>;

    /**
     * Get all bound tokens.
     */
    getCurrentTokens(): NonPayableTransactionObject<string[]>;

    /**
     * Returns the list of tokens which have a desired weight above 0. Tokens with a desired weight of 0 are set to be phased out of the pool.
     */
    getCurrentDesiredTokens(): NonPayableTransactionObject<string[]>;

    /**
     * Returns the denormalized weight of a bound token.
     */
    getDenormalizedWeight(token: string): NonPayableTransactionObject<string>;

    /**
     * Returns the record for a token bound to the pool.
     */
    getTokenRecord(
      token: string
    ): NonPayableTransactionObject<
      [boolean, boolean, string, string, string, string, string]
    >;

    /**
     * Finds the first token which is both initialized and has a desired weight above 0, then returns the address of that token and the extrapolated value of the pool in terms of that token. The value is extrapolated by multiplying the token's balance by the reciprocal of its normalized weight.
     */
    extrapolatePoolValueFromToken(): NonPayableTransactionObject<{
      0: string;
      1: string;
    }>;

    /**
     * Get the total denormalized weight of the pool.
     */
    getTotalDenormalizedWeight(): NonPayableTransactionObject<string>;

    /**
     * Returns the stored balance of a bound token.
     */
    getBalance(token: string): NonPayableTransactionObject<string>;

    /**
     * Get the minimum balance of an uninitialized token. Note: Throws if the token is initialized.
     */
    getMinimumBalance(token: string): NonPayableTransactionObject<string>;

    /**
     * Returns the balance of a token which is used in price calculations. If the token is initialized, this is the stored balance; if not, this is the minimum balance.
     */
    getUsedBalance(token: string): NonPayableTransactionObject<string>;

    /**
     * Returns the spot price for `tokenOut` in terms of `tokenIn`.
     */
    getSpotPrice(
      tokenIn: string,
      tokenOut: string
    ): NonPayableTransactionObject<string>;
  };
  events: {
    Approval(cb?: Callback<Approval>): EventEmitter;
    Approval(options?: EventOptions, cb?: Callback<Approval>): EventEmitter;

    LOG_DENORM_UPDATED(cb?: Callback<LOG_DENORM_UPDATED>): EventEmitter;
    LOG_DENORM_UPDATED(
      options?: EventOptions,
      cb?: Callback<LOG_DENORM_UPDATED>
    ): EventEmitter;

    LOG_DESIRED_DENORM_SET(cb?: Callback<LOG_DESIRED_DENORM_SET>): EventEmitter;
    LOG_DESIRED_DENORM_SET(
      options?: EventOptions,
      cb?: Callback<LOG_DESIRED_DENORM_SET>
    ): EventEmitter;

    LOG_EXIT(cb?: Callback<LOG_EXIT>): EventEmitter;
    LOG_EXIT(options?: EventOptions, cb?: Callback<LOG_EXIT>): EventEmitter;

    LOG_JOIN(cb?: Callback<LOG_JOIN>): EventEmitter;
    LOG_JOIN(options?: EventOptions, cb?: Callback<LOG_JOIN>): EventEmitter;

    LOG_MAX_TOKENS_UPDATED(cb?: Callback<LOG_MAX_TOKENS_UPDATED>): EventEmitter;
    LOG_MAX_TOKENS_UPDATED(
      options?: EventOptions,
      cb?: Callback<LOG_MAX_TOKENS_UPDATED>
    ): EventEmitter;

    LOG_MINIMUM_BALANCE_UPDATED(
      cb?: Callback<LOG_MINIMUM_BALANCE_UPDATED>
    ): EventEmitter;
    LOG_MINIMUM_BALANCE_UPDATED(
      options?: EventOptions,
      cb?: Callback<LOG_MINIMUM_BALANCE_UPDATED>
    ): EventEmitter;

    LOG_PUBLIC_SWAP_ENABLED(
      cb?: Callback<LOG_PUBLIC_SWAP_ENABLED>
    ): EventEmitter;
    LOG_PUBLIC_SWAP_ENABLED(
      options?: EventOptions,
      cb?: Callback<LOG_PUBLIC_SWAP_ENABLED>
    ): EventEmitter;

    LOG_SWAP(cb?: Callback<LOG_SWAP>): EventEmitter;
    LOG_SWAP(options?: EventOptions, cb?: Callback<LOG_SWAP>): EventEmitter;

    LOG_SWAP_FEE_UPDATED(cb?: Callback<LOG_SWAP_FEE_UPDATED>): EventEmitter;
    LOG_SWAP_FEE_UPDATED(
      options?: EventOptions,
      cb?: Callback<LOG_SWAP_FEE_UPDATED>
    ): EventEmitter;

    LOG_TOKEN_ADDED(cb?: Callback<LOG_TOKEN_ADDED>): EventEmitter;
    LOG_TOKEN_ADDED(
      options?: EventOptions,
      cb?: Callback<LOG_TOKEN_ADDED>
    ): EventEmitter;

    LOG_TOKEN_READY(cb?: Callback<LOG_TOKEN_READY>): EventEmitter;
    LOG_TOKEN_READY(
      options?: EventOptions,
      cb?: Callback<LOG_TOKEN_READY>
    ): EventEmitter;

    LOG_TOKEN_REMOVED(cb?: Callback<LOG_TOKEN_REMOVED>): EventEmitter;
    LOG_TOKEN_REMOVED(
      options?: EventOptions,
      cb?: Callback<LOG_TOKEN_REMOVED>
    ): EventEmitter;

    Transfer(cb?: Callback<Transfer>): EventEmitter;
    Transfer(options?: EventOptions, cb?: Callback<Transfer>): EventEmitter;

    allEvents(options?: EventOptions, cb?: Callback<EventLog>): EventEmitter;
  };

  once(event: "Approval", cb: Callback<Approval>): void;
  once(event: "Approval", options: EventOptions, cb: Callback<Approval>): void;

  once(event: "LOG_DENORM_UPDATED", cb: Callback<LOG_DENORM_UPDATED>): void;
  once(
    event: "LOG_DENORM_UPDATED",
    options: EventOptions,
    cb: Callback<LOG_DENORM_UPDATED>
  ): void;

  once(
    event: "LOG_DESIRED_DENORM_SET",
    cb: Callback<LOG_DESIRED_DENORM_SET>
  ): void;
  once(
    event: "LOG_DESIRED_DENORM_SET",
    options: EventOptions,
    cb: Callback<LOG_DESIRED_DENORM_SET>
  ): void;

  once(event: "LOG_EXIT", cb: Callback<LOG_EXIT>): void;
  once(event: "LOG_EXIT", options: EventOptions, cb: Callback<LOG_EXIT>): void;

  once(event: "LOG_JOIN", cb: Callback<LOG_JOIN>): void;
  once(event: "LOG_JOIN", options: EventOptions, cb: Callback<LOG_JOIN>): void;

  once(
    event: "LOG_MAX_TOKENS_UPDATED",
    cb: Callback<LOG_MAX_TOKENS_UPDATED>
  ): void;
  once(
    event: "LOG_MAX_TOKENS_UPDATED",
    options: EventOptions,
    cb: Callback<LOG_MAX_TOKENS_UPDATED>
  ): void;

  once(
    event: "LOG_MINIMUM_BALANCE_UPDATED",
    cb: Callback<LOG_MINIMUM_BALANCE_UPDATED>
  ): void;
  once(
    event: "LOG_MINIMUM_BALANCE_UPDATED",
    options: EventOptions,
    cb: Callback<LOG_MINIMUM_BALANCE_UPDATED>
  ): void;

  once(
    event: "LOG_PUBLIC_SWAP_ENABLED",
    cb: Callback<LOG_PUBLIC_SWAP_ENABLED>
  ): void;
  once(
    event: "LOG_PUBLIC_SWAP_ENABLED",
    options: EventOptions,
    cb: Callback<LOG_PUBLIC_SWAP_ENABLED>
  ): void;

  once(event: "LOG_SWAP", cb: Callback<LOG_SWAP>): void;
  once(event: "LOG_SWAP", options: EventOptions, cb: Callback<LOG_SWAP>): void;

  once(event: "LOG_SWAP_FEE_UPDATED", cb: Callback<LOG_SWAP_FEE_UPDATED>): void;
  once(
    event: "LOG_SWAP_FEE_UPDATED",
    options: EventOptions,
    cb: Callback<LOG_SWAP_FEE_UPDATED>
  ): void;

  once(event: "LOG_TOKEN_ADDED", cb: Callback<LOG_TOKEN_ADDED>): void;
  once(
    event: "LOG_TOKEN_ADDED",
    options: EventOptions,
    cb: Callback<LOG_TOKEN_ADDED>
  ): void;

  once(event: "LOG_TOKEN_READY", cb: Callback<LOG_TOKEN_READY>): void;
  once(
    event: "LOG_TOKEN_READY",
    options: EventOptions,
    cb: Callback<LOG_TOKEN_READY>
  ): void;

  once(event: "LOG_TOKEN_REMOVED", cb: Callback<LOG_TOKEN_REMOVED>): void;
  once(
    event: "LOG_TOKEN_REMOVED",
    options: EventOptions,
    cb: Callback<LOG_TOKEN_REMOVED>
  ): void;

  once(event: "Transfer", cb: Callback<Transfer>): void;
  once(event: "Transfer", options: EventOptions, cb: Callback<Transfer>): void;
}
